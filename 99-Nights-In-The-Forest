local WindUI = loadstring(game:HttpGet("https://raw.githubusercontent.com/Footagesus/WindUI/main/dist/main.lua"))()

-- –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Ç–µ–º—ã
WindUI.TransparencyValue = 0.15

WindUI:AddTheme({
    Name = "SNTTheme",
    Accent = "#18181b",
    Dialog = "#18181b",
    Outline = "#FFFFFF",
    Text = "#FFFFFF",
    Placeholder = "#000000",
    Background = "#0e0e10",
    Button = "#52525b",
    Icon = "#24ffed",
})

WindUI:SetTheme("SNTTheme")

-- –¶–≤–µ—Ç–æ–≤–∞—è –ø–∞–ª–∏—Ç—Ä–∞
local COLOR_PALETTE = {
    Primary   = Color3.fromHex("#24ffed"),
    Secondary = Color3.fromHex("#000c63"),
    Accent    = Color3.fromHex("#30ff6a"),
    Dark      = Color3.fromHex("#0a0a1a"),
    Text      = Color3.fromHex("#e0e0ff"),
    Danger    = Color3.fromHex("#ff3e3e")
}

-- –§—É–Ω–∫—Ü–∏—è –≥—Ä–∞–¥–∏–µ–Ω—Ç–∞
local function gradient(text, startColor, endColor)
    local result = ""
    for i = 1, #text do
        local t = (i - 1) / (#text - 1)
        local r = math.floor((startColor.R + (endColor.R - startColor.R) * t) * 255)
        local g = math.floor((startColor.G + (endColor.G - startColor.G) * t) * 255)
        local b = math.floor((startColor.B + (endColor.B - startColor.B) * t) * 255)
        result = result .. string.format('<font color="rgb(%d,%d,%d)">%s</font>', r, g, b, text:sub(i, i))
    end
    return result
end

-- –°–æ–∑–¥–∞–Ω–∏–µ –æ–∫–Ω–∞
local Window = WindUI:CreateWindow({
    Title = gradient("SNT HUB", COLOR_PALETTE.Primary, COLOR_PALETTE.Text),
    Icon = "infinity",
    Author = gradient("99 Nights in the Forest", COLOR_PALETTE.Primary, COLOR_PALETTE.Text),
    Folder = "SNT_HUB",
    Size = UDim2.fromOffset(400, 180),
    Theme = "Dark",
    Background = WindUI:Gradient({
        ["0"]   = { Color = COLOR_PALETTE.Dark,      Transparency = 0 },
        ["50"]  = { Color = COLOR_PALETTE.Secondary, Transparency = 0 },
        ["100"] = { Color = Color3.fromHex("#000000"), Transparency = 0 },
    }, { Rotation = 150 }),
    User = {
        Enabled = true,
        Anonymous = false,
        Username = "Snowt_Scripter",
        UserTag = "@Snowt_Scripter",
        Callback = function()
            WindUI:Notify({
                Title = "User Profile",
                Content = "Telegram: @Snowt_TG",
                Duration = 3
            })
        end
    },
    SideBarWidth = 200,
    ScrollBarEnabled = true,
    CornerRadius = UDim.new(0, 14),
    DropShadow = true
})

-- –°–µ–∫—Ü–∏–∏
local MainSection = Window:Section({ 
    Title = gradient("MAIN", COLOR_PALETTE.Primary, COLOR_PALETTE.Text),
    Opened = true 
})

local GameSection = Window:Section({ 
    Title = gradient("GAME", COLOR_PALETTE.Primary, COLOR_PALETTE.Text),
    Opened = true
})

local SettingsSection = Window:Section({ 
    Title = gradient("SETTINGS", COLOR_PALETTE.Primary, COLOR_PALETTE.Text),
    Opened = true
})

-- –¢–∞–±—ã
local InfoTab       = MainSection:Tab({ Title = "INFO", Icon = "info" })
local SocialsTab    = MainSection:Tab({ Title = "SOCIALS", Icon = "users" })
local CharacterTab  = MainSection:Tab({ Title = "CHARACTER", Icon = "user" })

local TeleportTab = GameSection:Tab({ Title = "TELEPORT", Icon = "refresh-cw" })
local ChestTab = GameSection:Tab({ Title = "CHEST", Icon = "chest" })
local ItemsTab = GameSection:Tab({ Title = "ITEMS", Icon = "box" })
local EspTab = GameSection:Tab({ Title = "ESP", Icon = "eye" })
local CombatTab = GameSection:Tab({ Title = "COMBAT", Icon = "sword" })

local GameSettingsTab = SettingsSection:Tab({ Title = "GAME SETTINGS", Icon = "settings" })
local ServerTab       = SettingsSection:Tab({ Title = "SERVER", Icon = "server" })
local AutoExecuteTab  = SettingsSection:Tab({ Title = "AUTO EXECUTE", Icon = "play" })

-- =====================
-- –†–ï–ê–õ–ò–ó–ê–¶–ò–Ø INFO TAB
-- =====================

local FpsParagraph, PingParagraph, PlayersParagraph, GameParagraph

local frameCount = 0
local lastTime = tick()
local currentFPS = 0

game:GetService("RunService").RenderStepped:Connect(function()
    frameCount += 1
end)


-- –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è FPS
local function updateFPS()
    local now = tick()
    local delta = now - lastTime

    if delta >= 1 then
        currentFPS = frameCount / delta
        frameCount = 0
        lastTime = now
    end

    return math.floor(currentFPS)
end

-- –°–æ–∑–¥–∞–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ Info Tab
FpsParagraph = InfoTab:Paragraph({
    Title     = gradient("FPS: --",    COLOR_PALETTE.Primary, COLOR_PALETTE.Text),
    Desc      = "Loading...",
    Image     = "activity",
    ImageSize = 20,
    Color     = "White"
})

PingParagraph = InfoTab:Paragraph({
    Title     = gradient("PING: --",   COLOR_PALETTE.Primary, COLOR_PALETTE.Text),
    Desc      = "Loading...",
    Image     = "signal",
    ImageSize = 20,
    Color     = "White"
})

PlayersParagraph = InfoTab:Paragraph({
    Title     = gradient("PLAYERS: --", COLOR_PALETTE.Primary, COLOR_PALETTE.Text),
    Desc      = "Loading...",
    Image     = "users",
    ImageSize = 20,
    Color     = "White"
})

GameParagraph = InfoTab:Paragraph({
    Title     = gradient("GAME: --",   COLOR_PALETTE.Primary, COLOR_PALETTE.Text),
    Desc      = "Loading...",
    Image     = "gamepad",
    ImageSize = 20,
    Color     = "White"
})

-- –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏
local function updateInfo()
    -- –ü–æ–ª—É—á–∞–µ–º FPS
    local fps = updateFPS() or 0

    -- –ü–æ–ª—É—á–∞–µ–º Ping (–∑–∞–≥–ª—É—à–∫–∞)
    local ping = math.random(30, 120)

    -- –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –∏–≥—Ä–æ–∫–∞—Ö
    local players    = #game:GetService("Players"):GetPlayers()
    local maxPlayers = game:GetService("Players").MaxPlayers

    -- –û–±–Ω–æ–≤–ª—è–µ–º Paragraph‚Äô—ã
    FpsParagraph:SetTitle(gradient("FPS: "..fps,  COLOR_PALETTE.Primary, fps > 60 and COLOR_PALETTE.Accent or COLOR_PALETTE.Danger))
    FpsParagraph:SetDesc(fps > 60 and "Excellent performance" or "Low performance")

    PingParagraph:SetTitle(gradient("PING: "..ping.."ms", COLOR_PALETTE.Primary, ping < 80 and COLOR_PALETTE.Accent or COLOR_PALETTE.Danger))
    PingParagraph:SetDesc(ping < 80 and "Good connection" or "High latency")

    PlayersParagraph:SetTitle(gradient("PLAYERS: "..players.."/"..maxPlayers, COLOR_PALETTE.Primary, COLOR_PALETTE.Text))
    PlayersParagraph:SetDesc("Currently in server")

    GameParagraph:SetTitle(gradient(game:GetService("MarketplaceService"):GetProductInfo(game.PlaceId).Name, COLOR_PALETTE.Primary, COLOR_PALETTE.Text))
    GameParagraph:SetDesc("Current game")
end


-- –ö–Ω–æ–ø–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
InfoTab:Button({
    Title = gradient("Refresh Info", COLOR_PALETTE.Primary, COLOR_PALETTE.Accent),
    Icon = "refresh-cw",
    Callback = function()
        updateInfo()
        WindUI:Notify({
            Title = "Info Updated",
            Content = "Game information refreshed",
            Duration = 1
        })
    end
})

-- –ü–µ—Ä–≤–∏—á–Ω–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
updateInfo()

-- –ê–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–∞–∂–¥—É—é —Å–µ–∫—É–Ω–¥—É
spawn(function()
    while wait(1) do
        updateInfo()
    end
end)

-- ========================
-- –†–ï–ê–õ–ò–ó–ê–¶–ò–Ø SOCIALS TAB
-- ========================

-- TikTok
local TikTokParagraph = SocialsTab:Paragraph({
    Title     = gradient("My TikTok", COLOR_PALETTE.Primary, COLOR_PALETTE.Text),
    Desc      = "Please join to my TikTok account",
    Image     = "video",
    ImageSize = 20,
    Color     = "White"
})

SocialsTab:Button({
    Title    = gradient("TikTok", COLOR_PALETTE.Primary, COLOR_PALETTE.Accent),
    Desc     = "Copy link on my TikTok",
    Icon     = "copy",
    Callback = function()
        setclipboard("https://www.tiktok.com/@snowt.scripts?_t=ZT-8yhrbnIUFLL&_r=1")
        WindUI:Notify({
            Title   = "Link Copied",
            Content = "TikTok link copied to clipboard",
            Duration = 2
        })
    end
})

-- YouTube
local YouTubeParagraph = SocialsTab:Paragraph({
    Title     = gradient("YouTube", COLOR_PALETTE.Primary, COLOR_PALETTE.Text),
    Desc      = "Check out my YouTube channel",
    Image     = "youtube",
    ImageSize = 20,
    Color     = "White"
})

SocialsTab:Button({
    Title    = gradient("YouTube", COLOR_PALETTE.Primary, COLOR_PALETTE.Accent),
    Desc     = "Copy link to my YouTube",
    Icon     = "copy",
    Callback = function()
        setclipboard("https://youtube.com/@snowt_team?si=AmXDJj0qFQB-dzhv")
        WindUI:Notify({
            Title   = "Link Copied",
            Content = "YouTube link copied to clipboard",
            Duration = 2
        })
    end
})

-- Telegram
local TelegramParagraph = SocialsTab:Paragraph({
    Title     = gradient("Telegram", COLOR_PALETTE.Primary, COLOR_PALETTE.Text),
    Desc      = "Join my Telegram channel",
    Image     = "send",
    ImageSize = 20,
    Color     = "White"
})

SocialsTab:Button({
    Title    = gradient("Telegram", COLOR_PALETTE.Primary, COLOR_PALETTE.Accent),
    Desc     = "Copy link to my Telegram",
    Icon     = "copy",
    Callback = function()
        setclipboard("https://t.me/snowtscripts")
        WindUI:Notify({
            Title   = "Link Copied",
            Content = "Telegram link copied to clipboard",
            Duration = 2
        })
    end
})


-- ========================
-- –†–ï–ê–õ–ò–ó–ê–¶–ò–Ø CHARACTER TAB
-- ========================

-- –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏–π
local walkspeed = 16
local jumpPower = 50
local gravity = 196.2
local noclip = false
local infiniteJump = false

-- –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è –∏–∑–º–µ–Ω–µ–Ω–∏–π –∫ –ø–µ—Ä—Å–æ–Ω–∞–∂—É
local function updateCharacter()
    local character = game:GetService("Players").LocalPlayer.Character
    if character and character:FindFirstChild("Humanoid") then
        character.Humanoid.WalkSpeed = walkspeed
        character.Humanoid.JumpPower = jumpPower
    end
    game:GetService("Workspace").Gravity = gravity
end

-- Slider –¥–ª—è —Å–∫–æ—Ä–æ—Å—Ç–∏ –ø–µ—Ä–µ–¥–≤–∏–∂–µ–Ω–∏—è
CharacterTab:Slider({
    Title = gradient("WalkSpeed", COLOR_PALETTE.Primary, COLOR_PALETTE.Text),
    Desc = "Set movement speed (16 is default)",
    Value = { Min = 0, Max = 200, Default = walkspeed },
    Callback = function(value)
        walkspeed = value
        updateCharacter()
    end
})

-- Slider –¥–ª—è —Å–∏–ª—ã –ø—Ä—ã–∂–∫–∞
CharacterTab:Slider({
    Title = gradient("Jump Power", COLOR_PALETTE.Primary, COLOR_PALETTE.Text),
    Desc = "Set jump height (50 is default)",
    Value = { Min = 0, Max = 200, Default = jumpPower },
    Callback = function(value)
        jumpPower = value
        updateCharacter()
    end
})

-- Slider –¥–ª—è –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏–∏
CharacterTab:Slider({
    Title = gradient("Gravity", COLOR_PALETTE.Primary, COLOR_PALETTE.Text),
    Desc = "Set world gravity (196.2 is default)",
    Value = { Min = 0, Max = 500, Default = gravity },
    Callback = function(value)
        gravity = value
        updateCharacter()
    end
})

-- Toggle –¥–ª—è Noclip
CharacterTab:Toggle({
    Title = gradient("Noclip", COLOR_PALETTE.Primary, COLOR_PALETTE.Text),
    Desc = "Walk through walls",
    Value = noclip,
    Callback = function(state)
        noclip = state
        if state then
            -- –ê–∫—Ç–∏–≤–∞—Ü–∏—è –Ω–æ–∫–ª–∏–ø–∞
            local noclipLoop
            noclipLoop = game:GetService("RunService").Stepped:Connect(function()
                if game:GetService("Players").LocalPlayer.Character then
                    for _, part in pairs(game:GetService("Players").LocalPlayer.Character:GetDescendants()) do
                        if part:IsA("BasePart") then
                            part.CanCollide = false
                        end
                    end
                end
            end)
            _G.NoclipLoop = noclipLoop
        else
            -- –î–µ–∞–∫—Ç–∏–≤–∞—Ü–∏—è
            if _G.NoclipLoop then
                _G.NoclipLoop:Disconnect()
            end
        end
    end
})

-- Toggle –¥–ª—è –±–µ—Å–∫–æ–Ω–µ—á–Ω—ã—Ö –ø—Ä—ã–∂–∫–æ–≤
CharacterTab:Toggle({
    Title = gradient("Infinite Jump", COLOR_PALETTE.Primary, COLOR_PALETTE.Text),
    Desc = "Jump in mid-air",
    Value = infiniteJump,
    Callback = function(state)
        infiniteJump = state
        if state then
            -- –ê–∫—Ç–∏–≤–∞—Ü–∏—è –±–µ—Å–∫–æ–Ω–µ—á–Ω—ã—Ö –ø—Ä—ã–∂–∫–æ–≤
            local connection
            connection = game:GetService("UserInputService").JumpRequest:Connect(function()
                if game:GetService("Players").LocalPlayer.Character then
                    game:GetService("Players").LocalPlayer.Character.Humanoid:ChangeState("Jumping")
                end
            end)
            _G.InfiniteJumpConnection = connection
        else
            -- –î–µ–∞–∫—Ç–∏–≤–∞—Ü–∏—è
            if _G.InfiniteJumpConnection then
                _G.InfiniteJumpConnection:Disconnect()
            end
        end
    end
})

-- –ö–Ω–æ–ø–∫–∞ —Å–±—Ä–æ—Å–∞ –Ω–∞—Å—Ç—Ä–æ–µ–∫
CharacterTab:Button({
    Title = gradient("Reset to Default", COLOR_PALETTE.Primary, COLOR_PALETTE.Accent),
    Icon = "refresh-ccw",
    Callback = function()
        walkspeed = 16
        jumpPower = 50
        gravity = 196.2
        noclip = false
        infiniteJump = false
        
        updateCharacter()
        
        if _G.NoclipLoop then
            _G.NoclipLoop:Disconnect()
        end
        
        if _G.InfiniteJumpConnection then
            _G.InfiniteJumpConnection:Disconnect()
        end
        
        WindUI:Notify({
            Title = "Reset Complete",
            Content = "All settings reset to default",
            Duration = 2
        })
    end
})

-- –ö–Ω–æ–ø–∫–∞ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è —Ç–µ–º—ã
Window:CreateTopbarButton("theme-switcher", "moon", function()
    WindUI:SetTheme(WindUI:GetCurrentTheme() == "Dark" and "Light" or "Dark")
    WindUI:Notify({
        Title = "Theme Changed",
        Content = "Current theme: "..WindUI:GetCurrentTheme(),
        Duration = 2
    })
end, 990)

-- ========================
-- –†–ï–ê–õ–ò–ó–ê–¶–ò–Ø TELEPORT TAB
-- ========================

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Workspace = game:GetService("Workspace")
local HttpService = game:GetService("HttpService")

-- --------------- –£–¢–ò–õ–ò–¢–´ ---------------

local function getHRP(character)
    if not character then return nil end
    return character:FindFirstChild("HumanoidRootPart") or character:FindFirstChild("Torso")
end

local function getInstanceCFrame(obj)
    if not obj or not obj.Parent then return nil end
    if obj:IsA("BasePart") then
        return obj.CFrame
    elseif obj:IsA("Model") then
        if obj.PrimaryPart then
            return obj.PrimaryPart.CFrame
        else
            local okPivot, cf = pcall(function() return obj:GetPivot() end)
            if okPivot and cf then return cf end
            local okBox, cfb = pcall(function()
                local cframe, _ = obj:GetBoundingBox()
                return cframe
            end)
            if okBox and cfb then return cfb end
        end
    end
    return nil
end

local function teleportToCFrame(cf)
    local char = LocalPlayer.Character
    if not char then
        WindUI:Notify({ Title = "Teleport", Content = "Character not found", Duration = 2 })
        return
    end
    local hrp = getHRP(char)
    if not hrp then
        WindUI:Notify({ Title = "Teleport", Content = "HumanoidRootPart not found", Duration = 2 })
        return
    end
    -- –Ω–µ–±–æ–ª—å—à–æ–π –ø–æ–¥—ä—ë–º, —á—Ç–æ–±—ã –Ω–µ –∑–∞—Å—Ç—Ä—è—Ç—å
    local target = cf * CFrame.new(0, 3, 0)
    pcall(function()
        if char.PivotTo then
            char:PivotTo(target)
        else
            hrp.CFrame = target
        end
    end)
end

local function safeGet(pathFn)
    local ok, result = pcall(pathFn)
    if ok then return result end
    return nil
end

-- --------------- –ö–≠–®–ò –ò –û–ë–ù–û–í–õ–ï–ù–ò–ï –õ–ò–°–¢–û–í ---------------

local StructureMap, StructureNames = {}, {}
local ItemMap, ItemNames = {}, {}
local PlayerMap, PlayerNames = {}, {}

local function uniquifyName(map, base)
    if not map[base] then return base end
    local i = 2
    while map[base .. " [" .. i .. "]"] do
        i += 1
    end
    return base .. " [" .. i .. "]"
end

local function refreshStructures()
    StructureMap, StructureNames = {}, {}
    local folder = Workspace:FindFirstChild("Structures")
    if folder then
        for _, inst in ipairs(folder:GetChildren()) do
            local label = uniquifyName(StructureMap, inst.Name)
            StructureMap[label] = inst
            table.insert(StructureNames, label)
        end
    end
    table.sort(StructureNames)
end

local function refreshItems()
    ItemMap, ItemNames = {}, {}
    local folder = Workspace:FindFirstChild("Items")
    if folder then
        for _, inst in ipairs(folder:GetChildren()) do
            local label = uniquifyName(ItemMap, inst.Name)
            ItemMap[label] = inst
            table.insert(ItemNames, label)
        end
    end
    table.sort(ItemNames)
end

local function refreshPlayers()
    PlayerMap, PlayerNames = {}, {}
    -- –ò–≥—Ä–æ–∫–∏ (–∂–∏–≤—ã–µ –ø–µ—Ä—Å–æ–Ω–∞–∂–∏)
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and plr.Character then
            local char = plr.Character
            local label = uniquifyName(PlayerMap, "Player | " .. plr.Name)
            PlayerMap[label] = char
            table.insert(PlayerNames, label)
        end
    end
    -- NPC –∏ —Å—É—â–µ—Å—Ç–≤–∞
    local charsFolder = Workspace:FindFirstChild("Characters")
    if charsFolder then
        for _, inst in ipairs(charsFolder:GetChildren()) do
            local label = uniquifyName(PlayerMap, "NPC | " .. inst.Name)
            PlayerMap[label] = inst
            table.insert(PlayerNames, label)
        end
    end
    table.sort(PlayerNames)
end

-- --------------- –ö–û–û–†–î–ò–ù–ê–¢–´ (–°–û–•–†–ê–ù–ï–ù–ò–ï –í –≠–ö–°–ü–õ–û–ò–¢) ---------------

getgenv().SNT_HUB_SavedCoords = getgenv().SNT_HUB_SavedCoords or {}
local SavedCoords = getgenv().SNT_HUB_SavedCoords

local SavedCoordsMap, SavedCoordsNames = {}, {}

local function refreshSavedCoords()
    SavedCoordsMap, SavedCoordsNames = {}, {}
    for name, cf in pairs(SavedCoords) do
        SavedCoordsMap[name] = cf
        table.insert(SavedCoordsNames, name)
    end
    table.sort(SavedCoordsNames)
end

local function saveCurrentCoords(name)
    local char = LocalPlayer.Character
    local hrp = getHRP(char or {})
    if not hrp then
        WindUI:Notify({ Title = "Coordinates", Content = "HRP not found", Duration = 2 })
        return
    end
    if not name or name == "" then
        local n = 1
        while SavedCoords["Slot " .. n] do n += 1 end
        name = "Slot " .. n
    end
    SavedCoords[name] = hrp.CFrame
    refreshSavedCoords()
    WindUI:Notify({ Title = "Coordinates", Content = ("Saved as '%s'"):format(name), Duration = 2 })
end

local function parseXYZ(text)
    -- –æ–∂–∏–¥–∞–µ—Ç—Å—è —Ñ–æ—Ä–º–∞—Ç: x,y,z (—á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é, –ø—Ä–æ–±–µ–ª—ã –∏–≥–Ω–æ—Ä–∏–º)
    if not text or text == "" then return nil end
    local cleaned = text:gsub("[\n\r]", ""):gsub("%s+", "")
    local parts = {}
    for value in string.gmatch(cleaned, "([^,]+)") do
        table.insert(parts, value)
    end
    if #parts ~= 3 then return nil end
    local x = tonumber(parts[1])
    local y = tonumber(parts[2])
    local z = tonumber(parts[3])
    if not (x and y and z) then return nil end
    return Vector3.new(x, y, z)
end

-- --------------- UI: –°–ï–ö–¶–ò–ò –ò –ö–û–ù–¢–†–û–õ–´ ---------------

-- –ó–∞–≥–æ–ª–æ–≤–∫–∏-—Å–µ–∫—Ü–∏–∏
TeleportTab:Paragraph({
    Title = gradient("STRUCTURES", COLOR_PALETTE.Primary, COLOR_PALETTE.Text),
    Desc  = "Teleport to any structure on the map",
    Image = "map",
    ImageSize = 18,
    Color = "White"
})

-- –û–±–Ω–æ–≤–∏—Ç—å –∏ –∑–∞–ø–æ–ª–Ω–∏—Ç—å —Å–ø–∏—Å–∫–∏ –≤–ø–µ—Ä–≤—ã–µ
refreshStructures()
refreshItems()
refreshPlayers()
refreshSavedCoords()

-- STRUCTURES
local selectedStructure = nil
local StructuresDropdown = TeleportTab:Dropdown({
    Title = "Structures",
    Values = StructureNames,
    Value = StructureNames[1],
    Multi = false,
    AllowNone = true,
    Callback = function(choice)
        selectedStructure = choice
    end
})

TeleportTab:Button({
    Title = gradient("Teleport to Structure", COLOR_PALETTE.Primary, COLOR_PALETTE.Accent),
    Icon = "navigation",
    Callback = function()
        if not selectedStructure or not StructureMap[selectedStructure] then
            WindUI:Notify({ Title="Structures", Content="Select a structure first", Duration=2 })
            return
        end
        local cf = getInstanceCFrame(StructureMap[selectedStructure])
        if cf then
            teleportToCFrame(cf)
        else
            WindUI:Notify({ Title="Structures", Content="CFrame not found for target", Duration=2 })
        end
    end
})

TeleportTab:Button({
    Title = "Refresh Structures",
    Icon = "refresh-cw",
    Callback = function()
        refreshStructures()
        StructuresDropdown:Refresh(StructureNames)
        WindUI:Notify({ Title="Structures", Content="List refreshed", Duration=1 })
    end
})

-- SPAWN
TeleportTab:Paragraph({
    Title = gradient("SPAWN", COLOR_PALETTE.Primary, COLOR_PALETTE.Text),
    Desc  = "Teleport to spawn location",
    Image = "target",
    ImageSize = 18,
    Color = "White"
})

TeleportTab:Button({
    Title = gradient("Teleport to Spawn", COLOR_PALETTE.Primary, COLOR_PALETTE.Accent),
    Icon = "target",
    Callback = function()
        local spawnLoc = safeGet(function() return Workspace.Map.SpawnLocation end)
        if spawnLoc and spawnLoc.CFrame then
            teleportToCFrame(spawnLoc.CFrame)
        else
            WindUI:Notify({ Title="Spawn", Content="SpawnLocation not found", Duration=2 })
        end
    end
})

-- ITEMS
TeleportTab:Paragraph({
    Title = gradient("ITEMS", COLOR_PALETTE.Primary, COLOR_PALETTE.Text),
    Desc  = "Teleport to any item on the map",
    Image = "box",
    ImageSize = 18,
    Color = "White"
})

local selectedItem = nil
local ItemsDropdown = TeleportTab:Dropdown({
    Title = "Items",
    Values = ItemNames,
    Value = ItemNames[1],
    Multi = false,
    AllowNone = true,
    Callback = function(choice)
        selectedItem = choice
    end
})

TeleportTab:Button({
    Title = gradient("Teleport to Item", COLOR_PALETTE.Primary, COLOR_PALETTE.Accent),
    Icon = "navigation",
    Callback = function()
        if not selectedItem or not ItemMap[selectedItem] then
            WindUI:Notify({ Title="Items", Content="Select an item first", Duration=2 })
            return
        end
        local cf = getInstanceCFrame(ItemMap[selectedItem])
        if cf then
            teleportToCFrame(cf)
        else
            WindUI:Notify({ Title="Items", Content="CFrame not found for item", Duration=2 })
        end
    end
})

TeleportTab:Button({
    Title = "Refresh Items",
    Icon = "refresh-cw",
    Callback = function()
        refreshItems()
        ItemsDropdown:Refresh(ItemNames)
        WindUI:Notify({ Title="Items", Content="List refreshed", Duration=1 })
    end
})

-- PLAYERS
TeleportTab:Paragraph({
    Title = gradient("PLAYERS", COLOR_PALETTE.Primary, COLOR_PALETTE.Text),
    Desc  = "Teleport to players or NPCs",
    Image = "users",
    ImageSize = 18,
    Color = "White"
})

local selectedPlayerLabel = nil
local PlayersDropdown = TeleportTab:Dropdown({
    Title = "Players / NPC",
    Values = PlayerNames,
    Value = PlayerNames[1],
    Multi = false,
    AllowNone = true,
    Callback = function(choice)
        selectedPlayerLabel = choice
    end
})

TeleportTab:Button({
    Title = gradient("Teleport to Target", COLOR_PALETTE.Primary, COLOR_PALETTE.Accent),
    Icon = "navigation",
    Callback = function()
        if not selectedPlayerLabel or not PlayerMap[selectedPlayerLabel] then
            WindUI:Notify({ Title="Players", Content="Select a player/NPC first", Duration=2 })
            return
        end
        local target = PlayerMap[selectedPlayerLabel]
        local cf = getInstanceCFrame(getHRP(target)) or getInstanceCFrame(target)
        if cf then
            teleportToCFrame(cf)
        else
            WindUI:Notify({ Title="Players", Content="CFrame not found for target", Duration=2 })
        end
    end
})

TeleportTab:Button({
    Title = "Refresh Players / NPCs",
    Icon = "refresh-cw",
    Callback = function()
        refreshPlayers()
        PlayersDropdown:Refresh(PlayerNames)
        WindUI:Notify({ Title="Players", Content="List refreshed", Duration=1 })
    end
})

-- COORDINATES
TeleportTab:Paragraph({
    Title = gradient("COORDINATES", COLOR_PALETTE.Primary, COLOR_PALETTE.Text),
    Desc  = "Save/teleport using coordinates",
    Image = "map-pin",
    ImageSize = 18,
    Color = "White"
})

local selectedSaved = nil
local SavedDropdown = TeleportTab:Dropdown({
    Title = "Saved coordinates",
    Values = SavedCoordsNames,
    Value = SavedCoordsNames[1],
    Multi = false,
    AllowNone = true,
    Callback = function(choice)
        selectedSaved = choice
    end
})

TeleportTab:Button({
    Title = gradient("Teleport to Saved", COLOR_PALETTE.Primary, COLOR_PALETTE.Accent),
    Icon = "navigation",
    Callback = function()
        if not selectedSaved or not SavedCoordsMap[selectedSaved] then
            WindUI:Notify({ Title="Coordinates", Content="Choose saved coordinates", Duration=2 })
            return
        end
        teleportToCFrame(SavedCoordsMap[selectedSaved])
    end
})

TeleportTab:Button({
    Title = "Save Current Position (auto name)",
    Icon = "save",
    Callback = function()
        saveCurrentCoords(nil)
        refreshSavedCoords()
        SavedDropdown:Refresh(SavedCoordsNames)
    end
})

TeleportTab:Button({
    Title = "Remove Selected Saved",
    Icon = "trash-2",
    Callback = function()
        if not selectedSaved or not SavedCoords[selectedSaved] then
            WindUI:Notify({ Title="Coordinates", Content="Nothing selected", Duration=2 })
            return
        end
        SavedCoords[selectedSaved] = nil
        refreshSavedCoords()
        SavedDropdown:Refresh(SavedCoordsNames)
        WindUI:Notify({ Title="Coordinates", Content="Removed", Duration=1 })
    end
})

-- Clipboard helpers (–µ—Å–ª–∏ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç getclipboard/setclipboard)
TeleportTab:Button({
    Title = "Copy Current Coords to Clipboard",
    Icon = "copy",
    Callback = function()
        local char = LocalPlayer.Character
        local hrp = getHRP(char or {})
        if not hrp then
            WindUI:Notify({ Title="Clipboard", Content="HRP not found", Duration=2 })
            return
        end
        local v = hrp.Position
        local text = string.format("%.3f, %.3f, %.3f", v.X, v.Y, v.Z)
        if setclipboard then
            setclipboard(text)
            WindUI:Notify({ Title="Clipboard", Content="Coords copied", Duration=1 })
        else
            WindUI:Notify({ Title="Clipboard", Content="setclipboard not available", Duration=2 })
        end
    end
})

TeleportTab:Button({
    Title = "Teleport to Clipboard Coords (x,y,z)",
    Icon = "map",
    Callback = function()
        if not getclipboard then
            WindUI:Notify({ Title="Clipboard", Content="getclipboard not available", Duration=2 })
            return
        end
        local text = getclipboard()
        local vec = parseXYZ(text)
        if not vec then
            WindUI:Notify({ Title="Clipboard", Content="Invalid format. Use: x,y,z", Duration=3 })
            return
        end
        teleportToCFrame(CFrame.new(vec))
    end
})


-- ========================
-- –†–ï–ê–õ–ò–ó–ê–¶–ò–Ø CHEST TAB
-- ========================

local ChestMap, ChestNames = {}, {}

local function refreshChests()
    ChestMap, ChestNames = {}, {}
    local itemsFolder = workspace:FindFirstChild("Items")
    if itemsFolder then
        for _, item in ipairs(itemsFolder:GetChildren()) do
            if string.find(string.lower(item.Name), "chest") then
                local label = item.Name
                if ChestMap[label] then
                    local i = 2
                    while ChestMap[label.." ["..i.."]"] do i += 1 end
                    label = label.." ["..i.."]"
                end
                ChestMap[label] = item
                table.insert(ChestNames, label)
            end
        end
    end
    table.sort(ChestNames)
end

refreshChests()

-- üìä –ü–∞—Ä–∞–≥—Ä–∞—Ñ: –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å—É–Ω–¥—É–∫–æ–≤
ChestTab:Paragraph({
    Title = gradient("CHESTS: "..#ChestNames, COLOR_PALETTE.Primary, COLOR_PALETTE.Text),
    Desc = "All chests available on the map",
    Image = "archive",
    ImageSize = 20,
    Color = "White"
})

-- üß≠ –î—Ä–æ–ø–¥–∞—É–Ω –≤—ã–±–æ—Ä–∞ —Å—É–Ω–¥—É–∫–∞
local selectedChest = ChestNames[1]
local ChestDropdown = ChestTab:Dropdown({
    Title = "Available Chests",
    Values = ChestNames,
    Value = selectedChest,
    Multi = false,
    AllowNone = true,
    Callback = function(value)
        selectedChest = value
    end
})

-- üìç –¢–µ–ª–µ–ø–æ—Ä—Ç –∫ —Å—É–Ω–¥—É–∫—É
ChestTab:Button({
    Title = gradient("Teleport to Chest", COLOR_PALETTE.Primary, COLOR_PALETTE.Accent),
    Icon = "navigation",
    Callback = function()
        local chest = ChestMap[selectedChest]
        if chest and chest:IsA("Model") then
            local cf = chest.PrimaryPart and chest.PrimaryPart.CFrame or chest:GetBoundingBox()
            teleportToCFrame(cf)
        end
    end
})

-- üóùÔ∏è –û—Ç–∫—Ä—ã—Ç–∏–µ —Å—É–Ω–¥—É–∫–∞ —á–µ—Ä–µ–∑ RemoteEvent
ChestTab:Button({
    Title = gradient("Open Chest (RemoteEvent)", COLOR_PALETTE.Primary, COLOR_PALETTE.Accent),
    Icon = "unlock",
    Callback = function()
        local chest = ChestMap[selectedChest]
        if chest then
            local RemoteEvent = game:GetService("ReplicatedStorage"):WaitForChild("RemoteEvents"):WaitForChild("RequestOpenItemChest")
            RemoteEvent:FireServer(chest)
            WindUI:Notify({
                Title = "Chest Opened",
                Content = "Opened via RemoteEvent",
                Duration = 2
            })
        end
    end
})

-- üîì –û—Ç–∫—Ä—ã—Ç–∏–µ —á–µ—Ä–µ–∑ ProximityPrompt
ChestTab:Button({
    Title = gradient("Open Chest (Proximity)", COLOR_PALETTE.Primary, COLOR_PALETTE.Accent),
    Icon = "key",
    Callback = function()
        local chest = ChestMap[selectedChest]
        local prompt = chest and chest:FindFirstDescendant("ProximityInteraction")
        if prompt and prompt:IsA("ProximityPrompt") then
            prompt:InputHoldBegin()
            task.delay(1, function() prompt:InputHoldEnd() end)
            WindUI:Notify({
                Title = "Chest Opened",
                Content = "Via Proximity Prompt",
                Duration = 2
            })
        else
            WindUI:Notify({
                Title = "No Prompt",
                Content = "ProximityPrompt not found",
                Duration = 2
            })
        end
    end
})

-- ‚ôªÔ∏è –û–±–Ω–æ–≤–∏—Ç—å —Å–ø–∏—Å–æ–∫ —Å—É–Ω–¥—É–∫–æ–≤
ChestTab:Button({
    Title = "Refresh Chest List",
    Icon = "refresh-cw",
    Callback = function()
        refreshChests()
        ChestDropdown:Refresh(ChestNames)
        WindUI:Notify({
            Title = "Chest List",
            Content = "List updated",
            Duration = 1
        })
    end
})

-- üîÅ –ê–≤—Ç–æ–æ—Ç–∫—Ä—ã—Ç–∏–µ —Å—É–Ω–¥—É–∫–æ–≤
local autoOpen = false

ChestTab:Toggle({
    Title = gradient("Auto Open Chests", COLOR_PALETTE.Primary, COLOR_PALETTE.Text),
    Desc = "Continuously open all chests around you",
    Value = autoOpen,
    Callback = function(state)
        autoOpen = state
        if state then
            spawn(function()
                while autoOpen do
                    for _, chest in pairs(ChestMap) do
                        local prompt = chest:FindFirstDescendant("ProximityInteraction")
                        if prompt and prompt:IsA("ProximityPrompt") then
                            prompt:InputHoldBegin()
                            task.delay(0.5, function() prompt:InputHoldEnd() end)
                        else
                            local RemoteEvent = game:GetService("ReplicatedStorage"):WaitForChild("RemoteEvents"):WaitForChild("RequestOpenItemChest")
                            RemoteEvent:FireServer(chest)
                        end
                    end
                    task.wait(3)
                end
            end)
        end
    end
})


-- ========================
-- –†–ï–ê–õ–ò–ó–ê–¶–ò–Ø ITEMS TAB
-- ========================

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local LocalPlayer = Players.LocalPlayer

local function HRP()
    local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    return char:WaitForChild("HumanoidRootPart")
end

-- –£—Ç–∏–ª–∏—Ç—ã –¥–ª—è remotes
local RemoteFolders = {
    "RemoteEvents", "Remotes", "Events", "RE", "Network", "Net"
}

local function findRemote(folderNames, remoteName)
    for _, fname in ipairs(folderNames) do
        local folder = ReplicatedStorage:FindFirstChild(fname)
        if folder and folder:FindFirstChild(remoteName) then
            return folder[remoteName]
        end
    end
    return nil
end

local R_RequestPickupItem = findRemote(RemoteFolders, "RequestPickupItem")
local R_RequestUseConsumable = findRemote(RemoteFolders, "RequestUseConsumable")
local R_RequestStoreItem = findRemote(RemoteFolders, "RequestStoreItem")
local R_RequestBurnItem = findRemote(RemoteFolders, "RequestBurnItem")
local F_GetInventory = (function()
    for _, fname in ipairs({"RemoteFunctions","RF","Functions"}) do
        local f = ReplicatedStorage:FindFirstChild(fname)
        if f and f:FindFirstChild("GetInventory") then
            return f["GetInventory"]
        end
    end
    return nil
end)()

-- –ü–æ–∏—Å–∫ Prompt –≤–Ω—É—Ç—Ä–∏ –æ–±—ä–µ–∫—Ç–∞
local function findPrompt(instance)
    if not instance then return nil end
    if instance:IsA("ProximityPrompt") then return instance end
    local prompt = instance:FindFirstChildOfClass("ProximityPrompt")
    if prompt then return prompt end
    for _, d in ipairs(instance:GetDescendants()) do
        if d:IsA("ProximityPrompt") then
            return d
        end
    end
    return nil
end

-- –ú–µ—Ç–∫–∞ + —É–Ω–∏–∫–∞–ª–∏–∑–∞—Ü–∏—è –∏–º–µ–Ω–∏
local function uniqueLabel(map, base)
    local label = base
    if map[label] then
        local i = 2
        while map[("%s [%d]"):format(base, i)] do i += 1 end
        label = ("%s [%d]"):format(base, i)
    end
    return label
end

-- –°–∫–∞–Ω –ø—Ä–µ–¥–º–µ—Ç–æ–≤ –Ω–∞ –∫–∞—Ä—Ç–µ
local ItemsMap, ItemNames = {}, {}
local nameFilter = ""
local maxRadius = 0 -- 0 = –±–µ–∑ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è

local function distanceTo(pos)
    local hrp = HRP()
    return (hrp.Position - pos).Magnitude
end

local function getCFrameOf(inst)
    if inst:IsA("Model") then
        local pp = inst.PrimaryPart
        if pp then return pp.CFrame end
        local cf = select(1, inst:GetBoundingBox())
        return cf
    elseif inst:IsA("BasePart") then
        return inst.CFrame
    else
        local model = inst:FindFirstAncestorOfClass("Model")
        if model then
            local pp = model.PrimaryPart
            if pp then return pp.CFrame end
            return select(1, model:GetBoundingBox())
        end
    end
end

local function inRadius(inst)
    if maxRadius <= 0 then return true end
    local cf = getCFrameOf(inst)
    if not cf then return false end
    return distanceTo(cf.Position) <= maxRadius
end

local function matchesFilter(inst)
    if nameFilter == "" then return true end
    return string.find(string.lower(inst.Name), string.lower(nameFilter), 1, true) ~= nil
end

local function refreshItems()
    ItemsMap, ItemNames = {}, {}
    local itemsFolder = workspace:FindFirstChild("Items") or workspace:FindFirstChild("WorldItems") or workspace:FindFirstChild("Drops")
    if not itemsFolder then return end
    for _, obj in ipairs(itemsFolder:GetChildren()) do
        -- –°—á–∏—Ç–∞–µ–º –ø—Ä–µ–¥–º–µ—Ç–æ–º –ª—é–±–æ–π Model/BasePart —É –∫–æ—Ç–æ—Ä–æ–≥–æ –µ—Å—Ç—å ProximityPrompt –∏–ª–∏ –º–µ—Ç–∫–∞/–¥–∞—Ç–∞
        local isItem = false
        local prompt = findPrompt(obj)
        if prompt then
            isItem = true
        else
            if obj:IsA("BasePart") or obj:IsA("Model") then
                isItem = true
            end
        end
        if isItem and matchesFilter(obj) and inRadius(obj) then
            local label = uniqueLabel(ItemsMap, obj.Name)
            ItemsMap[label] = obj
            table.insert(ItemNames, label)
        end
    end
    table.sort(ItemNames)
end

refreshItems()

-- ================= UI: –ó–∞–≥–æ–ª–æ–≤–æ–∫ –∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ =================
ItemsTab:Paragraph({
    Title = gradient("ITEMS", COLOR_PALETTE.Primary, COLOR_PALETTE.Text),
    Desc = "Manage, collect and automate items on the map",
    Image = "package",
    ImageSize = 20,
    Color = "White"
})

local countParagraph = ItemsTab:Paragraph({
    Title = "Items found: " .. #ItemNames,
    Desc = "Filtered by name and radius",
    Image = "hash",
    ImageSize = 16,
    Color = "White"
})

local function updateCount()
    countParagraph:SetTitle("Items found: " .. #ItemNames)
end

-- ================= UI: –§–∏–ª—å—Ç—Ä—ã =================
ItemsTab:Input({
    Title = "Name filter",
    Placeholder = "e.g. berry, shard, potion...",
    Numeric = false,
    Finished = true,
    Callback = function(text)
        nameFilter = text or ""
        refreshItems()
        ItemDropdown:Refresh(ItemNames) -- forward declare
        updateCount()
    end
})

ItemsTab:Slider({
    Title = "Radius filter (0 = unlimited)",
    Min = 0,
    Max = 1000,
    Value = 0,
    Rounding = 0,
    Callback = function(val)
        maxRadius = val
        refreshItems()
        ItemDropdown:Refresh(ItemNames)
        updateCount()
    end
})

-- ================= UI: –°–ø–∏—Å–æ–∫ –∏ –≤—ã–±–æ—Ä =================
-- –û–±—ä—è–≤–∏ ItemDropdown –î–û Input/Slider
local selectedItem = ItemNames[1]
ItemDropdown = ItemsTab:Dropdown({
    Title = "Available Items",
    Values = ItemNames,
    Value = selectedItem,
    Multi = false,
    AllowNone = true,
    Callback = function(value)
        selectedItem = value
    end
})

ItemsTab:Button({
    Title = gradient("Refresh item list", COLOR_PALETTE.Primary, COLOR_PALETTE.Accent),
    Icon = "refresh-cw",
    Callback = function()
        refreshItems()
        ItemDropdown:Refresh(ItemNames)
        updateCount()
        WindUI:Notify({ Title = "Items", Content = "List updated", Duration = 1 })
    end
})

-- ================= –î–µ–π—Å—Ç–≤–∏—è: –¢–µ–ª–µ–ø–æ—Ä—Ç –∏ Bring =================
ItemsTab:Button({
    Title = gradient("Teleport to item", COLOR_PALETTE.Primary, COLOR_PALETTE.Accent),
    Icon = "navigation",
    Callback = function()
        local it = ItemsMap[selectedItem]
        local cf = it and getCFrameOf(it)
        if cf then
            teleportToCFrame(cf + Vector3.new(0, 3, 0))
        end
    end
})

ItemsTab:Button({
    Title = gradient("Bring item to me", COLOR_PALETTE.Primary, COLOR_PALETTE.Accent),
    Icon = "magnet",
    Callback = function()
        local it = ItemsMap[selectedItem]
        if not it then
            return WindUI:Notify({ Title = "Bring", Content = "No item selected", Duration = 1.5 })
        end
        local targetCF = CFrame.new(HRP().Position + Vector3.new(0, 2, -2))
        -- –ü–æ–ø—ã—Ç–∫–∞ –ª–æ–∫–∞–ª—å–Ω–æ –ø–µ—Ä–µ—Ç–∞—â–∏—Ç—å (—Ä–∞–±–æ—Ç–∞–µ—Ç –µ—Å–ª–∏ —É –∫–ª–∏–µ–Ω—Ç–∞ –µ—Å—Ç—å —Å–µ—Ç—å/–ø—Ä–∞–≤–æ)
        local function setOwnerAndPivot(modelOrPart, cf)
            local parts = {}
            if modelOrPart:IsA("Model") then
                for _, d in ipairs(modelOrPart:GetDescendants()) do
                    if d:IsA("BasePart") then table.insert(parts, d) end
                end
            elseif modelOrPart:IsA("BasePart") then
                parts = { modelOrPart }
            end
            for _, p in ipairs(parts) do
                p:SetNetworkOwner(LocalPlayer)
            end
            if modelOrPart:IsA("Model") then
                modelOrPart:PivotTo(cf)
            elseif modelOrPart:IsA("BasePart") then
                modelOrPart.CFrame = cf
            end
        end
        local ok, err = pcall(function()
            setOwnerAndPivot(it, targetCF)
        end)
        if ok then
            WindUI:Notify({ Title = "Bring", Content = "Item pulled to you", Duration = 1.2 })
        else
            -- –§–æ–ª–ª–±–µ–∫: –±—ã—Å—Ç—Ä–æ—Ç–∞—Ñ–ª –∫ –ø—Ä–µ–¥–º–µ—Ç—É –∏ –Ω–∞–∑–∞–¥
            local before = HRP().CFrame
            local icf = getCFrameOf(it)
            if icf then
                teleportToCFrame(icf + Vector3.new(0, 3, 0))
                task.wait(0.25)
                teleportToCFrame(before)
                WindUI:Notify({ Title = "Bring (fallback)", Content = "Teleported to item", Duration = 1.2 })
            else
                WindUI:Notify({ Title = "Bring", Content = "Failed to move item", Duration = 1.5 })
            end
        end
    end
})

-- ================= –ü–æ–¥–±–æ—Ä: Prompt / Remote =================
local function pickupViaPrompt(inst, holdTime)
    local prompt = findPrompt(inst)
    if not prompt then return false, "No ProximityPrompt" end
    prompt:InputHoldBegin()
    task.delay(holdTime or 0.6, function()
        prompt:InputHoldEnd()
    end)
    return true
end

local function pickupViaRemote(inst)
    if not R_RequestPickupItem then return false, "No Remote" end
    R_RequestPickupItem:FireServer(inst)
    return true
end

ItemsTab:Button({
    Title = gradient("Pickup (Proximity)", COLOR_PALETTE.Primary, COLOR_PALETTE.Accent),
    Icon = "hand",
    Callback = function()
        local it = ItemsMap[selectedItem]
        if not it then
            return WindUI:Notify({ Title = "Pickup", Content = "No item selected", Duration = 1.2 })
        end
        local ok = pickupViaPrompt(it, 0.5)
        WindUI:Notify({
            Title = "Pickup (Prompt)",
            Content = ok and "Collected" or "Prompt not found",
            Duration = 1.4
        })
    end
})

ItemsTab:Button({
    Title = gradient("Pickup (RemoteEvent)", COLOR_PALETTE.Primary, COLOR_PALETTE.Accent),
    Icon = "zap",
    Callback = function()
        local it = ItemsMap[selectedItem]
        if not it then
            return WindUI:Notify({ Title = "Pickup", Content = "No item selected", Duration = 1.2 })
        end
        local ok = pickupViaRemote(it)
        WindUI:Notify({
            Title = "Pickup (Remote)",
            Content = ok and "Requested" or "Remote not found",
            Duration = 1.4
        })
    end
})

-- ================= –ê–≤—Ç–æ—Ñ–∞—Ä–º –ø—Ä–µ–¥–º–µ—Ç–æ–≤ =================
local autoFarm = false
local farmDelay = 0.35
local preferPrompt = true

ItemsTab:Toggle({
    Title = gradient("Auto-farm items", COLOR_PALETTE.Primary, COLOR_PALETTE.Text),
    Desc = "Collect items around you on loop",
    Value = autoFarm,
    Callback = function(state)
        autoFarm = state
        if state then
            task.spawn(function()
                while autoFarm do
                    -- –ü—Ä–æ—Ö–æ–¥–∏–º –ø–æ —Ç–µ–∫—É—â–µ–º—É —Å—Ä–µ–∑—É, —á—Ç–æ–±—ã –∏—Ç–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —Å—Ç–∞–±–∏–ª—å–Ω–æ
                    local current = {}
                    for label, inst in pairs(ItemsMap) do
                        table.insert(current, {label = label, inst = inst})
                    end
                    -- –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—é
                    table.sort(current, function(a,b)
                        local ca = getCFrameOf(a.inst)
                        local cb = getCFrameOf(b.inst)
                        local da = ca and distanceTo(ca.Position) or math.huge
                        local db = cb and distanceTo(cb.Position) or math.huge
                        return da < db
                    end)
                    for _, rec in ipairs(current) do
                        if not autoFarm then break end
                        local inst = rec.inst
                        if inst and inst.Parent ~= nil then
                            local acted = false
                            if preferPrompt then
                                local ok = pickupViaPrompt(inst, 0.4)
                                acted = ok
                            end
                            if not acted then
                                pickupViaRemote(inst)
                            end
                            task.wait(farmDelay)
                        end
                    end
                    -- –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ (–Ω–∞ —Å–ª—É—á–∞–π –∏—Å—á–µ–∑–Ω—É–≤—à–∏—Ö –ø—Ä–µ–¥–º–µ—Ç–æ–≤)
                    refreshItems()
                    ItemDropdown:Refresh(ItemNames)
                    updateCount()
                    task.wait(0.8)
                end
            end)
        end
    end
})

ItemsTab:Slider({
    Title = "Autofarm delay (sec)",
    Min = 0.1,
    Max = 1.5,
    Value = farmDelay,
    Rounding = 2,
    Callback = function(v) farmDelay = v end
})

ItemsTab:Toggle({
    Title = "Prefer ProximityPrompt",
    Desc = "Try prompt first, then remote",
    Value = preferPrompt,
    Callback = function(v) preferPrompt = v end
})

-- ================= Consumables (–∏–Ω–≤–µ–Ω—Ç–∞—Ä—å) =================
local consumables = {}
local consumableNames = {}
local selectedConsumable
local useAmount = 1

local function loadInventory()
    consumables, consumableNames = {}, {}
    -- –ü–æ–ø—ã—Ç–∫–∞ –ø–æ–ª—É—á–∏—Ç—å —á–µ—Ä–µ–∑ RemoteFunction
    local inv = nil
    if F_GetInventory then
        local ok, res = pcall(function()
            return F_GetInventory:InvokeServer()
        end)
        if ok and type(res) == "table" then
            inv = res
        end
    end
    -- –§–æ–ª–ª–±–µ–∫: –∏—â–µ–º –≤ Backpack Tools –∫–∞–∫ "Potion"/"Elixir"
    if not inv then
        inv = {}
        local backpack = LocalPlayer:FindFirstChildOfClass("Backpack")
        if backpack then
            for _, tool in ipairs(backpack:GetChildren()) do
                if tool:IsA("Tool") and (tool.Name:lower():find("potion") or tool.Name:lower():find("elixir") or tool.Name:lower():find("consum")) then
                    table.insert(inv, { id = tool.Name, name = tool.Name, type = "Consumable", amount = 1 })
                end
            end
        end
    end
    for _, item in ipairs(inv) do
        if (item.type or item.category or ""):lower():find("consum") then
            local label = ("%s x%d"):format(item.name or item.id, item.amount or 1)
            table.insert(consumables, item)
            table.insert(consumableNames, label)
        end
    end
    if #consumableNames == 0 then
        selectedConsumable = nil
    else
        selectedConsumable = consumableNames[1]
    end
end

ItemsTab:Separator({ Text = "Consumables" })

loadInventory()

local consumableDropdown = ItemsTab:Dropdown({
    Title = "Your consumables",
    Values = consumableNames,
    Value = selectedConsumable,
    Multi = false,
    AllowNone = true,
    Callback = function(val)
        selectedConsumable = val
    end
})

ItemsTab:Button({
    Title = "Refresh inventory",
    Icon = "refresh-ccw",
    Callback = function()
        loadInventory()
        consumableDropdown:Refresh(consumableNames)
        WindUI:Notify({ Title = "Inventory", Content = "Refreshed", Duration = 1 })
    end
})

ItemsTab:Slider({
    Title = "Use amount",
    Min = 1,
    Max = 10,
    Value = useAmount,
    Rounding = 0,
    Callback = function(v) useAmount = v end
})

ItemsTab:Button({
    Title = gradient("Use selected consumable", COLOR_PALETTE.Primary, COLOR_PALETTE.Accent),
    Icon = "play",
    Callback = function()
        if not selectedConsumable then
            return WindUI:Notify({ Title = "Use", Content = "Nothing selected", Duration = 1.2 })
        end
        -- –ù–∞–π–¥–µ–º –æ–±—ä–µ–∫—Ç –ø–æ –ª–µ–π–±–ª—É
        local idx = table.find(consumableNames, selectedConsumable)
        local data = idx and consumables[idx]
        if not data then
            return WindUI:Notify({ Title = "Use", Content = "Consumable not found", Duration = 1.2 })
        end
        if R_RequestUseConsumable then
            R_RequestUseConsumable:FireServer(data.id or data.name, useAmount)
            WindUI:Notify({ Title = "Use", Content = "Requested use", Duration = 1.2 })
        else
            -- –§–æ–ª–ª–±–µ–∫: –ø–æ–ø—ã—Ç–∞—Ç—å—Å—è –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å Tool –∏–∑ Backpack
            local backpack = LocalPlayer:FindFirstChildOfClass("Backpack")
            local tool = backpack and backpack:FindFirstChild(data.name or data.id)
            if tool and tool:IsA("Tool") then
                local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
                tool.Parent = char
                task.wait(0.05)
                pcall(function() tool:Activate() end)
                task.wait(0.05)
                tool.Parent = backpack
                WindUI:Notify({ Title = "Use (fallback)", Content = "Tool activated", Duration = 1.2 })
            else
                WindUI:Notify({ Title = "Use", Content = "No remote/tool", Duration = 1.2 })
            end
        end
    end
})

-- ================= Store / Burn =================
ItemsTab:Separator({ Text = "Storage & Burn" })

ItemsTab:Button({
    Title = "Store selected item",
    Icon = "archive",
    Callback = function()
        local it = ItemsMap[selectedItem]
        if not it then
            return WindUI:Notify({ Title = "Store", Content = "No item selected", Duration = 1.2 })
        end
        if R_RequestStoreItem then
            R_RequestStoreItem:FireServer(it)
            WindUI:Notify({ Title = "Store", Content = "Requested store", Duration = 1.2 })
        else
            WindUI:Notify({ Title = "Store", Content = "Store remote not found", Duration = 1.2 })
        end
    end
})

local burnCount = 1
ItemsTab:Slider({
    Title = "Burn amount",
    Min = 1,
    Max = 50,
    Value = burnCount,
    Rounding = 0,
    Callback = function(v) burnCount = v end
})

ItemsTab:Button({
    Title = gradient("Burn duplicates", COLOR_PALETTE.Primary, COLOR_PALETTE.Accent),
    Icon = "flame",
    Callback = function()
        if not selectedConsumable then
            return WindUI:Notify({ Title = "Burn", Content = "Select item in Consumables", Duration = 1.2 })
        end
        local idx = table.find(consumableNames, selectedConsumable)
        local data = idx and consumables[idx]
        if not data then
            return WindUI:Notify({ Title = "Burn", Content = "Consumable not found", Duration = 1.2 })
        end
        if R_RequestBurnItem then
            R_RequestBurnItem:FireServer(data.id or data.name, burnCount)
            WindUI:Notify({ Title = "Burn", Content = "Requested burn", Duration = 1.2 })
        else
            WindUI:Notify({ Title = "Burn", Content = "Burn remote not found", Duration = 1.2 })
        end
    end
})

-- ================= QoL: –ê–≤—Ç–æ-store –ø–æ—Å–ª–µ –ø–æ–¥–±–æ—Ä–∞ =================
local autoStore = false
ItemsTab:Toggle({
    Title = "Auto-store after pickup",
    Desc = "Immediately store item when picked",
    Value = autoStore,
    Callback = function(v) autoStore = v end
})

-- –•—É–∫ –∫ –∞–≤—Ç–æ—Ñ–∞—Ä–º—É: –ø–æ—Å–ª–µ –ø–æ–ø—ã—Ç–∫–∏ –ø–æ–¥–±–æ—Ä–∞ ‚Äî –æ—Ç–ø—Ä–∞–≤–∏—Ç—å store
local oldPickupViaPrompt = pickupViaPrompt
pickupViaPrompt = function(inst, holdTime)
    local ok, err = oldPickupViaPrompt(inst, holdTime)
    if ok and autoStore and R_RequestStoreItem then
        task.defer(function() R_RequestStoreItem:FireServer(inst) end)
    end
    return ok, err
end

local oldPickupViaRemote = pickupViaRemote
pickupViaRemote = function(inst)
    local ok, err = oldPickupViaRemote(inst)
    if ok and autoStore and R_RequestStoreItem then
        task.defer(function() R_RequestStoreItem:FireServer(inst) end)
    end
    return ok, err
end
